# 分片上传系统实现原理

## 系统架构

本分片上传系统采用前后端分离架构，支持大文件断点续传、并发上传和完整性校验。

### 核心组件

```
前端:
├── React应用
├── useChunkUpload Hook (核心上传逻辑)
├── ChunkUpload组件 (UI界面)
├── fileUtils工具 (文件处理)
└── api服务 (HTTP请求)

后端:
├── Express服务器
├── Multer中间件 (文件上传)
├── 分片存储管理
└── 文件合并逻辑
```

## 核心实现原理

### 1. 文件分片处理

**前端分片逻辑:**
```javascript
// 将文件切分为固定大小的块
const CHUNK_SIZE = 2 * 1024 * 1024; // 2MB

function createFileChunks(file) {
  const chunks = [];
  for (let i = 0; i < file.size; i += CHUNK_SIZE) {
    const chunk = file.slice(i, i + CHUNK_SIZE);
    chunks.push({
      chunk,
      index: Math.floor(i / CHUNK_SIZE),
      size: chunk.size
    });
  }
  return chunks;
}
```

### 2. 文件哈希计算

**用途:** 文件去重和完整性校验
```javascript
// 使用MD5计算文件哈希
async function calculateHash(file) {
  const spark = new SparkMD5.ArrayBuffer();
  // 分块计算避免内存溢出
  for (let i = 0; i < file.size; i += CHUNK_SIZE) {
    const chunk = file.slice(i, i + CHUNK_SIZE);
    const arrayBuffer = await chunk.arrayBuffer();
    spark.append(arrayBuffer);
  }
  return spark.end();
}
```

### 3. 断点续传机制

**检查已上传分片:**
```javascript
// 前端发送检查请求
const checkResult = await checkFile(hash, filename);

// 后端返回已上传的分片索引
{
  exists: false,
  uploaded: false, 
  uploadedChunks: [0, 1, 3, 5] // 已上传的分片索引
}
```

**续传逻辑:**
```javascript
// 过滤出未上传的分片
const pendingChunks = chunks.filter(
  (_, index) => !uploadedChunks.includes(index)
);
```

### 4. 并发上传控制

**并发池管理:**
```javascript
const concurrency = 3; // 最大并发数

// 每个并发线程处理分片队列
const uploadNextChunk = async () => {
  while (chunkIndex < pendingChunks.length) {
    const chunk = pendingChunks[chunkIndex++];
    await uploadChunk(chunkData);
    // 更新进度状态
  }
};

// 创建并发上传线程
const uploadPromises = [];
for (let i = 0; i < Math.min(concurrency, pendingChunks.length); i++) {
  uploadPromises.push(uploadNextChunk());
}

await Promise.all(uploadPromises);
```

### 5. 服务端分片处理

**分片上传接口:**
```javascript
app.post('/api/upload-chunk', upload.single('chunk'), async (req, res) => {
  const { hash, chunkIndex } = req.body;
  
  // 创建分片目录: chunks/{hash}/
  const chunkPath = path.join(chunkDir, hash);
  await fs.ensureDir(chunkPath);
  
  // 移动临时文件到目标位置: chunk-{index}
  const targetPath = path.join(chunkPath, `chunk-${chunkIndex}`);
  await fs.move(req.file.path, targetPath);
});
```

### 6. 文件合并机制

**合并触发条件:**
- 所有分片上传完成
- 分片数量验证通过
- 分片完整性检查通过

**合并逻辑:**
```javascript
app.post('/api/merge-chunks', async (req, res) => {
  const { hash, filename, totalChunks } = req.body;
  
  // 1. 验证分片完整性
  const chunkFiles = chunks.filter(file => file.startsWith('chunk-'));
  if (chunkFiles.length !== totalChunks) {
    return res.status(400).json({ error: '文件块数量不匹配' });
  }
  
  // 2. 按序合并分片
  const writeStream = fs.createWriteStream(filePath);
  for (let i = 0; i < totalChunks; i++) {
    const chunkBuffer = await fs.readFile(`chunk-${i}`);
    writeStream.write(chunkBuffer);
  }
  
  // 3. 文件完整性校验
  const fileHash = crypto.createHash('md5').update(fileBuffer).digest('hex');
  if (fileHash !== hash) {
    return res.status(400).json({ error: '文件完整性校验失败' });
  }
  
  // 4. 清理临时文件
  await fs.remove(chunkPath);
});
```

## 状态管理

### 上传状态定义
```javascript
const uploadState = {
  file: null,           // 当前文件
  hash: '',            // 文件哈希
  chunks: [],          // 分片数组
  uploadedChunks: [],  // 已上传分片索引
  uploading: false,    // 上传状态
  progress: 0,         // 上传进度 (0-100)
  speed: 0,           // 上传速度 (bytes/s)
  remainingTime: 0,   // 剩余时间 (秒)
  canResume: false,   // 是否可续传
  success: false,     // 上传成功
  error: null         // 错误信息
};
```

### 进度计算
```javascript
// 进度计算
const progress = (uploadedChunks.length / totalChunks) * 100;

// 速度计算
const speed = uploadedBytes / elapsedTime;

// 剩余时间估算
const remainingTime = (totalBytes - uploadedBytes) / speed;
```

## 错误处理机制

### 1. 网络错误重试
- 分片上传失败自动重试
- 指数退避重试策略
- 最大重试次数限制

### 2. 文件完整性校验
- 上传前计算文件MD5
- 合并后重新校验MD5
- 校验失败自动清理文件

### 3. 异常状态恢复
- 页面刷新后状态恢复
- 网络中断后续传支持
- 服务器重启后分片保留

## 性能优化

### 1. 内存管理
- 分块读取大文件避免内存溢出
- 及时释放已处理的分片数据
- 限制并发数量控制内存占用

### 2. 网络优化
- 并发上传提高传输效率
- 分片大小平衡传输速度和重传成本
- HTTP/2支持多路复用

### 3. 存储优化
- 临时文件自动清理
- 重复文件去重存储
- 分片目录结构优化

## 安全考虑

### 1. 文件类型验证
- 前端文件类型检查
- 后端MIME类型验证
- 文件扩展名白名单

### 2. 大小限制
- 单文件大小限制
- 分片数量限制
- 总存储空间限制

### 3. 路径安全
- 文件名sanitize
- 路径遍历攻击防护
- 上传目录权限控制

## 部署配置

### 环境要求
- Node.js 16+
- 足够的磁盘空间用于临时存储
- 反向代理配置(nginx)支持大文件上传

### 关键配置
```javascript
// 服务器配置
const CHUNK_SIZE = 2 * 1024 * 1024;    // 2MB分片大小
const MAX_FILE_SIZE = 5 * 1024 * 1024 * 1024; // 5GB最大文件
const UPLOAD_CONCURRENCY = 3;          // 并发上传数
const CLEANUP_INTERVAL = 24 * 60 * 60 * 1000; // 24小时清理周期
```

## 总结

本分片上传系统通过前后端配合，实现了大文件的可靠上传：

1. **分片机制**: 将大文件切分为小块，降低传输风险
2. **断点续传**: 支持上传中断后继续，提升用户体验
3. **并发控制**: 多分片并发上传，提高传输效率
4. **完整性校验**: 确保上传文件的完整性和正确性
5. **错误恢复**: 完善的错误处理和恢复机制

系统具有良好的扩展性和稳定性，适合生产环境使用。